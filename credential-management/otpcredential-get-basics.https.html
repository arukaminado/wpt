<!DOCTYPE html>
<link rel="help" href="https://github.com/WICG/WebOTP">
<title>Tests OtpCredential</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<!--
 otpcredential-helper.js is a testing framework that enables engines to test
 OTPCredential by intercepting the connection between the browser and the
 underlying operating system and mock its behavior.

 Usage:

 1) Include <script src="./support/otpcredential-helper.js"></script> in your test.
 2) Set expectations
  await expect(receive).andReturn(() => {
    // mock behavior
  })
 3) Call navigator.credentials.get({otp: {transport: ["sms"]}})
 4) Verify results

 The mocking API is browser agnostic and is designed such that other engines
 could implement it too.

 Here are the symbols that are exposed to tests that need to be implemented
 per engine:

 - function receive(): the main/only function that can be mocked.
 - function expect(): the main/only function that enables us to mock it.
 - enum State {kSuccess, kTimeout}: allows you to mock success/failures.
  -->
<script src="./support/otpcredential-helper.js"></script>
<script>
'use strict';

promise_test(async t => {
  await expect(receive).andReturn(() => {
      return Promise.resolve({
        status: Status.kSuccess,
        otp: "ABC",
      });
  });

  let cred = await navigator.credentials.get({otp: {transport: ["sms"]}});

  assert_equals(cred.code, "ABC");
}, 'Basic usage');

promise_test(async t => {
  await expect(receive).andReturn(() => {
      return Promise.resolve({
        status: Status.kSuccess,
        otp: "ABC",
      });
  });
  await expect(receive).andReturn(() => {
      return Promise.resolve({
        status: Status.kSuccess,
        otp: "ABC2",
      });
  });

  let sms1 = navigator.credentials.get({otp: {transport: ["sms"]}});
  let sms2 = navigator.credentials.get({otp: {transport: ["sms"]}});

  let cred2= await sms2;
  let cred1 = await sms1;

  assert_equals(cred1.code, "ABC");
  assert_equals(cred2.code, "ABC2");
}, 'Handle multiple requests in different order.');

promise_test(async t => {
  await expect(receive).andReturn(() => {
      return Promise.resolve({
        status: Status.kCancelled,
      });
  });
  await expect(receive).andReturn(() => {
      return Promise.resolve({
        status: Status.kSuccess,
        otp: "success",
      });
  });

  let cancelled_sms = navigator.credentials.get({otp: {transport: ["sms"]}});
  let successful_sms = navigator.credentials.get({otp: {transport: ["sms"]}});

  let successful_cred = await successful_sms;
  assert_equals(successful_cred.code, "success");

  try {
    await cancelled_sms;
    assert_unreached('Expected AbortError to be thrown.');
  } catch (error) {
    assert_equals(error.name, "AbortError");
  }
}, 'Handle multiple requests with success and error.');

promise_test(async t => {
  await expect(receive).andReturn(() => {
      return Promise.resolve({
        status: Status.kCancelled,
      });
  });

  try {
    await navigator.credentials.get({otp: {transport: ["sms"]}});
    assert_unreached('Expected CancelledError to be thrown.');
  } catch (error) {
    assert_equals(error.name, "AbortError");
  }
}, 'Deal with cancelled requests');

promise_test(async t => {
  const controller = new AbortController();
  const signal = controller.signal;

  controller.abort();
  await promise_rejects_dom(t, 'AbortError', navigator.credentials.get(
    {otp: {transport: ["sms"]}, signal: signal}));
}, 'Should abort request');

</script>
